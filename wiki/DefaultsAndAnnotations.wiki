#summary Defaul Behaviour and Annotations in Piriti

= Default behaviour =
== Fields ==
When Piriti creates the reader / writer implementation for a type T, all fields of T and its superclasses which satisfy the following requirements are processed:
  * The field is accessible. If the reader / writer interface is defined as nested static class or in the same package, the field must have at least default access. If the field isn't accessible, there has to be an appropriate getter / setter.
  * The fields type must be [SupportedTypes supported] by Piriti   
  * The field must not be transient or marked with the @Transient annotation
  
Suppose you have the following types (all in the same package): 
{{{
public abstract class Creature
{
    String kind;
}

public abstract class Animal
{
    String name;
    int age;
    private String state;
}

public abstract class Mammal extends Animal
{
    private Gender gender;
    
    public Gender getHender()
    {
        return gender;
    } 
}

@MapUpTo(Animal.class)
public class Cat extends Mammal
{
    transient int size;
    @Transient String race;
    String color;
    List<Cat> kitten;
    Map<Stirng, String> metadata;
}
}}}
and this reader definition
{{{
public CatReader extends JsonReader<Cat>
{
}
}}}
then the following fields are read by this reader:
  * name
  * age
  * gender
  * color
  * kitten
These fields are *not* processed:
  * kind: It's in type which is out of reach (excluded by @MapUpTo)
  * state: Field is private and no accessible getter was defined
  * size: Field is transient
  * race: Field was marked with @Transient
  * metadata: Type is not supported

== Path ==
TODO
 
== Conversion == 
TODO
 
= Annotations =
The dafault behaviour can be customized using a handfuil of annotations:
  * @Path
  * @Format
  * @Convert
  * @Whitespace
  * @Getter / @Setter
  * @CreateWith 
  * @MapUpTo
  * @Order
  * @Transient
  * @Native
TODO