#summary Namespace handling.

<wiki:toc/>

= Introduction =
Starting with version 0.4 Piriti supports namespaces in XML documents and XPath expressions. This was possible due to a change of the underlying XML parser and XPath engine ([http://code.google.com/intl/de-DE/webtoolkit/doc/latest/DevGuideCodingBasicsXML.html GWTs XML parser] and [http://code.google.com/p/gwtxpath/ gwtxpath] were exchanged by [http://code.google.com/p/totoe/ Totoe]. 

When mapping XML documents we have to distinguish two use cases:
  # XML documents *without* a default namespace
  # XML documents *with* a default namespace

= XML without a default namespace = 
That's the easy part, so we start with this. Suppose you have the following XML document
{{{
<?xml version="1.0" encoding="UTF-8"?>
<lotteryTicket xmlns:foo="http://code.google.com/p/piriti/foo"
    xmlns:bar="http://code.google.com/p/piriti/bar" date="10.10.2010">

    <foo:player foo:gender="male" age="42">
        <foo:firstname>Homer</foo:firstname>
        <foo:surname>Simpson</foo:surname>
        <bar:address bar:type="home" foo:valid="true">
            24, evergreen terrace, springfield
        </bar:address>
    </foo:player>

    <numbers game="6x49">
        <number>4</number>
        <number>8</number>
        <number>15</number>
        <number>16</number>
        <number>23</number>
        <number>42</number>
    </numbers>

</lotteryTicket>
}}}

and you want to map this XML to the following POJOs
{{{
public class LotteryTicket
{
    Date date;
    Player player;
    String game;
    List<Integer> numbers;
}

public class Player
{
    Gender gender;
    int age;
    String firstname;
    String surname;
    String address;
    String addressType;
    boolean validAddress;
}

public enum Gender
{
    FEMALE,
    MALE
}
}}}

To do this you need to 
  # Specify the namespaces when parsing the XML
  # add the namespace prefix to the XPath expression in your {{{@XmlField}}} annotation

== Specify namespaces ==
When parsing the XML you have to specify the namespaces. This can be done in two ways:
  * By providing a whilespace-seperated list of namespace declarations as those would appear in an XML document:
    {{{
String namespaces = "xmlns:foo=\"http://code.google.com/p/piriti/foo\" "
    + "xmlns:bar=\"http://code.google.com/p/piriti/bar\"";
Document document = new XmlParser().parse(xmlAsString, namespaces);
    }}}
  * By providing a map with the namespace prefix as key and the namespace URI as value:
    {{{
Map<String,String> namespaces = new HashMap<String,String>();
namespaces.put("foo", "http://code.google.com/p/piriti/foo");
namespaces.put("bar", "http://code.google.com/p/piriti/bar");
Document document = new XmlParser().parse(xmlAsString, namespaces);
    }}}

== Add namespace to the annotations ==
In the annotations of your POJOs you have to adjust the XPath expressions to include the namespace prefix:
{{{
public class LotteryTicket
{
    public interface LotteryTicketReader extends XmlReader<LotteryTicket> {}
    public static final LotteryTicketReader XML = GWT.create(LotteryTicketReader.class);

    @XmlField(value = "@date", format = "dd.MM.yyyy") Date date;
    @XmlField("foo:player") Player player;
    @XmlField("numbers/@game") String game;
    @XmlField("numbers/number") List<Integer> numbers;
}

public class Player
{
    public interface PlayerXmlReader extends XmlReader<Player> {}
    public static final PlayerXmlReader XML = GWT.create(PlayerXmlReader.class);

    @XmlField("@foo:gender") Gender gender;
    @XmlField("@age") int age;
    @XmlField("foo:firstname/text()") String firstname;
    @XmlField("foo:surname/text()") String surname;
    @XmlField("bar:address/text()") String address;
    @XmlField("bar:address/@bar:type") String addressType;
    @XmlField("bar:address/@foo:valid") boolean validAddress;
}
}}}


= XML with a default namespace = 
Things get a little 