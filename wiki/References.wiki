#summary References in Piriti
#labels polymorph

<wiki:toc max_depth="2" />

= References in Java =
When a reader / writer is instantiated it is registered against a global registry. Therefore references to other types that also have a reader / writer are recognized and mapped:
{{{
public class Book
{
    interface BookReader extends XmlReader<Book> {}
    public static final BookReader XML = GWT.create(BookReader.class);

    String name;
    Author author;
}
}}}
{{{
public class Author
{
    interface AuthorReader extends XmlReader<Author> {}
    public static final AuthorReader XML = GWT.create(AuthorReader.class);

    String firstname;
    String surname;
}
}}}
When reading a book from JSON / XML which also contains author information, the author is mapped and assigned to Book.author.

== Requirements ==
In order to use references following conditions must be met:
  All readers / writers of types which make up the references must be initialized *before* the first reader / writer is used. 
  
In the above example !AuthorReader has to be initialized _before_ !BookReader.read() is called. Initialized means the call of GWT.create() has to happen. As long as you declare your reader / writer instances as static members, Piriti will take care of this. Once you have your reader / writer instances _outside_ of your POJO, you have to take care of the initialization by yourself:
{{{
public class Book
{
    String name;
    Author author;
}
}}}
{{{
public class Author
{
    String firstname;
    String surname;
}
}}}
{{{
public interface BookReader extends XmlReader<Book> {}
}}}
{{{
public interface AuthorReader extends XmlReader<Author> {}
}}}
{{{
public final class Readers 
{
    public static final BookReader BOOK_READER = GWT.create(BookReader.class);
    public static final AuthorReader AUTHOR_READER = GWT.create(AuthorReader.class);
    
    // Just there to have a method to call, load the class and trigger GWT.create() calls
    public void initialize() {}
}
}}}
{{{
public class AppEntryPoint implements EntryPoint
{
    public void onModuleLoad()
    {
        Readers.initialize();
        ...
    }
}
}}}

Whenever possible I strongly recommend to use [ReaderWriter#GIN_Setup GIN] to create and initialize your reader / writer instances. Doing so you can be sure that all readers / writers are initialized and registered before you (de)serialize your first POJO. 
         
== Polymorphic References ==
Piriti supports the mapping of polymorphic references as shown in the following example (reader definitions omitted)
{{{
{
  "mediums": [
    {
      "id": "isbn-978-0345417954",
      "title": "The Hotel New Hampshire",
      "pages": 432
    },
    {
      "id": "cd-1234",
      "title": "Stadium Arcadium",
      "tracks": 28
    },
    {
      "id": "dvd-5678",
      "title": "Reservoir Dogs",
      "duration": 99
    }
  ]
}
}}}
{{{
public class Library
{
    List<Medium> mediums;
}

public abstract class Medium
{
    String id;
    String title;
}

public class Book extends Medium
{
    int pages;
}

public class Cd extends Medium
{
    int tracks;
}

public class Dvd extends Medium
{
    int duration;
}
}}} 

In order to map the medium list in Library, Piriti has to know how to create concrete instances of Medium subclasses. Therefore you have to specify an [Annotations#CreateWith InstanceCreator] for the list using the @!CreateWith annotation:
{{{
public class Library
{
    @CreateWith(MediumCreator.class)
    List<Medium> mediums;
}
}}}
{{{
public class MediumCreator extends JsonInstanceCreator<Medium>
{
    @Override
    public Medium newInstance(JSONValue context)
    {
        Medium medium = null;
        JSONObject jsonObject = context.isObject();
        if (jsonObject != null)
        {
            JSONValue idValue = jsonObject.get("id");
            if (idValue != null)
            {
                JSONString idString = idValue.isString();
                if (idString != null)
                {
                    String id = idString.stringValue();
                    if (id.startsWith("isbn-"))
                    {
                        medium = new Book();
                    }
                    else if (id.startsWith("cd-"))
                    {
                        medium = new Cd();
                    }
                    if (id.startsWith("dvd-"))
                    {
                        medium = new Dvd();
                    }
                }
            }
        }
        return medium;
    }
}
}}}
  
The important part here is that you need an indicator in your JSON / XML data to decide which instance to create. Otherwise polymorphic references wonn't work.     

= References in JSON / XML =

== Introduction ==
Often you have references in XML. Piriti can resolve those references if expressed by ID and IDREF. Let's take the following XML document as an example:
{{{
<company>
    <employees>
        <employee id="boss">
            <name>Big Boss</name>
            <team>
                <member ref="seller" />
                <member ref="engineer" />
            </team>
            <department ref="board" />
        </employee>
        <employee id="seller">
            <name>Sally Seller</name>
            <boss ref="boss" />
            <department ref="sales" />
        </employee>
        <employee id="engineer">
            <name>Ed Engineer</name>
            <boss ref="boss" />
            <team>
                <member ref="coder" />
                <member ref="tester" />
            </team>
            <department ref="it" />
        </employee>
        <employee id="coder">
            <name>Carl Coder</name>
            <boss ref="engineer" />
            <department ref="it" />
        </employee>
        <employee id="tester">
            <name>Tom Tester</name>
            <boss ref="engineer" />
            <department ref="it" />
        </employee>
    </employees>
    <departments>
        <department id="board">
            <name>Board</name>
            <employees members="boss" />
        </department>
        <department id="sales">
            <name>Sales</name>
            <employees members="seller" />
        </department>
        <department id="it">
            <name>IT</name>
            <employees members="engineer coder tester" />
        </department>
    </departments>
</company>
}}}
The XML document uses references for
  * team members
  * employees of a department and
  * departments itself

Piriti supports the mapping of those references. So you end up with references to other POJOs in the mapped POJO. In the given example the 'boss' POJO has references to the 'seller' and 'engineer' POJO.

== Mapping ==
Let's take a look at the mapping: 
{{{
public class Employee
{
    public interface EmployeeReader extends XmlReader<Employee> {}
    public static final EmployeeReader XML = GWT.create(EmployeeReader.class);

    @Id @Path("@id") String id;
    String name;
    @IdRef @Path("boss/@ref") Employee boss;
    @IdRef @Path("team/member/@ref") List<Employee> team;
    @IdRef @Path("department/@ref") Department department;
}

public class Department
{
    public interface DepartmentReader extends XmlReader<Department> {}
    public static final DepartmentReader XML = GWT.create(DepartmentReader.class);

    @Id @Path("@id") String id;
    String name;
    @IdRef @Path("employees/@members") Employee[] employees;
}
}}}

== @Id ==
Identifiers in the XML document have to be marked with the @Id annotation. If necessary specify an XPath expressions to select the id value. The selected value is mapped to a String member of the POJO. The @Id annotation can be used only once in a POJO. The POJO instance which contains the @Id annotation is put into an internal map using the identifier as key. 

== @!IdRef == 
Using the @!IdRef annotation you can define reference to other elements in the XML document. These elements must contain an identifier marked with @Id. Specify an XPath expressions to select one or multiple strings. 
  * One string value: The type of the field marked with the @!IdRef annotation has to be a type with a registered reader. 
  * Multiple string values: The type of the field has to be an array or collection of types with a registered reader. 